# Сервисо-ориентированная архитектура
состоит из компонентов, взаимодействующих в облочной сети. Есть ~~интерфейсы~~/спецификации/стандарты (для разработки) которые определяют стандарты передачи данных.
Сервисо-ориентированная архитектура не обязательно является веб-системой. Она может быть также быть и **tcp**,  **websocket** и иным протоколом прикладного уровня. 
Есть специальные компоненты (специальные компоненты являются серверами, которые имею свою специализированной назначение):
 - ESP enterprice
 - system bus - предназначена для обмена информацией сервисами (клиент же подключается к этой шине для работы с сервисами)
 - реест - хранит адреса всех сервисов
 - workflow - позволяет запускать сервисы в некоторой последовательности, связывать их между собой
 - supervizor - следит за сервисами, перезапускает их при необходимости
 - service broker - преобразует клиентские запросы в запросы сервисов
 - identity service - выдача токенов
 - health service - опрашивает состояние других сервисов на предмет их "здоровья"
 - gateaway API service - позволяет создавать единую точку (для общения клиента с множеством сервисов)
(перечислить их, рассказать о них, для чего они нужны)
Все сервисо-ориентированные приложения имеют два ярко выраженных архитекрутных стиля : REST или RPC (есть ещё и гибридные)

# REST API
Что такое rest api,  чем представляет конечная точка (представляется в виде удалённой коллекции), какие требования к самому сервису (чтобы там ничего не кешировалось на строне сервера,не сохранял состояние на стороне сервера, чтобы он представлялся перед клиентом как единая неделимая сущность )
форматы передачи:
 - JSON(чаще всего)
 - XML
**HATEOAS** (*Hypermedia As The Engine Of Application State*) - подход в разработке сервисов, где вместе с ответом возвращаются ссылки на то, что может быть абсолютно где угодно. Позволяет отвязать клиентский код от зашиция в них конкретных данных. Стало необходимым для разработки на стороне клиента с помощью js-фреймфорков (react, angular). Они хранятся отдельно, присылаясь от того сервиса, к которому потом обращаются. Они никак не должны быть привязаны к какому-то конкретному серверу. Поэтому они вместе с ответами должны получать ссылки, на которые они должны динамически настраиваться
Популярные платформы, на которых можетт разрабатываться rest api: AWS

# RPC
вызов клиентом на стороне сервера удалённых процедур, сервер их обрабатывает,  и получает результат выполнения. Обычно этот подход порождается специальным описанием IDM.
**IDM** (*Interface Definition Language*) - язык для описания способа взаимодействия клиента и сервера. С помощью этого языка описывается интерфейс, а потом генерируются исходные коды клиентских и серверных стабов (на клиенте их ещё называют прокси). Позволяет программисту сильно не вникать в процесс взаимодейтсвия с удалённым сервером.
привести примеры (g-rpc, json-rpc)

# SOAP
Протокол прикладного уровня, который специально разрабатывался для сервисо-ориентированной архитектуры. Фактически представляется для мгновенной передачи данных. Используется формат XML. Эксплуатируется понятие namedspace, которое позволяет безмерно нагружать все soap сообщения, что называется ... бесконечной информацией. Сам протокол видит только необходимые данные и выполняет пересылку, а окончательной обработкой занимается целевой сервис.
soap - XML-ьный код, который содержит header, body(обязательно), информацию об ошибке(fail).
Позволяет создавать сложные сети, а не только точка к точке. Пересылается в основном в HTML, в content-type обычно указывается application/soap+xml. Широко используется в AWS и **DAPSAFE** (*Distributed Application Processing Secure Architecture For Enterprise*)

# WSDL
один и язывок IDL, который использовался в DAPSAFE. Описывается в формате xml: первый от компании SUN. Потом уже появился protobuf. 
WSDL содержит в себе описание типов, которые передаются в каждый параметр и возвращают значеня (как и в protobuf), конечные точки, которые называются порты (как и в protobuf), описывает сообщения, которые могут передаваться, транспорт, который может использоваться для передачи. 
Задумывался как язык для проектировщиков сервисов. в DAPSAFE была утилита, которая позволяла генерировать прокси и стаб. Более мощный, чем protobuf. То есть это язык для написания сервисов.

# Web-механизмы серверных уведомлений
pooling
long-poling (запрос с задержкой) 
sse server
websocket
push-server

# JSON RPC
Содержит форматы передачи сообщений запросов и ответов. Можем перемещать сообщения в любом транспорте (чаще HTTP но может быть и другие). Если перемещаем в HTTP то он находиться в теле запроса и сопровождается заголовком Content-Type: application/json. Запросы, ответы, уедомления не требующие ответа, пакетная обработка

# Протокол GRPC
Удалённый вызов процедур. Протокол основан на базе HTTP2.0. Разработка GOOGLE. Рассказать про RPC (всё что знаете), что это архитектурный стиль; рассказать что сначала разрабатывается protobuff, потом компилируется этот protobuff файл, который содержит описание в два файла или прото и сервер, то есть есть специальный компилятор который может компилировать прото-файл или в клиентский или в серверный стаб. На клиентской стороне просто используем его(вызываем методы объекта). На стороне сервере получаем базовый класс, от которого можем унаследоваться и заместить виртуальные методы.

# Высоконагруженные системы
В основном все системы сейчас такие, так как работают круглосуточно, не выключаются, неравномерная нагрузка может быть в некоторые периоды и в зависимости от этого выстраиваются решения пронизывающие от железа до приложения (масштабирование и т.д.). На лету можно менять модули, останавливать, запускать то есть такой модульный подход. 

# Docker 
В AWS, Azure используется активно. Когда мы скачиваем любое приложение, то оно в любом случае упаковывается в контейнер. Что такое докер, устройство, принципы, позволяющие его создать (ядро линукса, немспэйсы, всё в линуксе - файл). Платформа позволяет поместить приложение в контейнер, который даёт возможность легко разворачивать прилодение. Состоит из двух частей: клиентской - docker engine и серверной - docker hub (сервис для хранения образов image, может синхронизироваться с репозиторием на нашем компьютере). Есть cli интерфейс с помощью которого можно запускать. Есть Dockerfile в котором описывается процесс контейнеризации приложения.

# Kafka
Это приложение, которое относиться к классу MOM (приложения ориентированное на передачу сообщений), используется в сервисных системах для обмена информацией между сервисами. Называется вообще брокер сообщений. Встроены в aws, azure. Понятия Producer, provider, consuimer, topic, partitions, offset.

# Фрейморк SignalR
Фрейморк, встроенный в фсп дотнет кор и поддерживается в других системах программирования. Фреймворк, который позваляет нам осуществить обмен сообщениями между клиентом и сервером, под ним скрыто то, что он сам занимается выбором транспорта (web sockets - sse - long pooling). От нас он скрывает всё, взаимодействие клиента и сервера является прозрачным. Клиент и сервер могут быть написаны на рзаных языках программирования. Чаще всего используется для работы с браузерным приложением, также и межсервсиные могут быть.

# Сервер NGINX 
Сервер, который чаще всего применяется как прокси - сервер (есть forward (лежит ближе к клиенту) и revers (к серверу)). Надо рассказать зачем используется в веб - системах (для хранения стайлингов, для проксирования запросов, для разделения запросов на несколько ..., для балансировки нагрузки, протоколировать запросы, https (от клиента к нему https а от него к бэку идёт http) и т.д.). Находиться между клиентом и сервером. 

# Health check 
пециальный сервис для оценки состояния других сервисов. В таком случае, каждый сервис должен иметь одну или несколько точек, к которым можно обратиться и получить состояние сервиса. Состояние может быть простое (здоров/не здоров) или какие то более сложные структуры (связанные с базой данных например и т.д.). Использует системы Kubernetes, который используется для запуска и балансировки контейнеров сервисов.

# JOBS
Механизм, с помощью которого можно организовать оффлайновую работу, позволяет запускать отложенные задания в рамках отдельного процесса или потока, причём задание мы можем запускать с какой то периодичнойсть, одноразово, в отложенном режиме, по расписанию и т.д. Он ничего не возвращет, просто что то изменяет. Фреймовр Hangfire, архитектурные решения.

# Протокол WebDav
Протокол для работы с удалённым хранилищем, которое является файловой системой. Расширение протокола HTTP (больше методов). Раскидано по разным RFC но не все поддерживают все RFC. Разные команды для файловой системы в общем есть (круды и т.д.). 

# Механизм Push-server
Это механизм, который опирается на браузерные возможности, который позволяет нам сделайть уведомление о состоянии с сервера. Он работаерт над HTTP2.0. В основе его лежит специальный сервис, который есть у каждого браузера. То есть пуш сервер работает через промежуточный сервис, который приписсан к этому браузеру. Архитектура: генериться ключ, который отдаётся клиенту, клиент рассшифровывает и т.д., в конце концов сервер и клиент договариваются и браузер может узнавать от состоянии, которые есть на стороне сервера.

# Микросервисы
Тоже сервис-ориентированная орхитектура, только маленькие сервисы, которые можно быстро переписать. В основе проектирования лежит принцип ..... База данных, для хранения команд, из за которых она будет изменяться. Микросервисы поддерживают два варианта управления: оркестрация и хореография. Основные паттерны проектирования.

# Платформа AWS 
Рассказать, что за платформа. Какие сервисы, Бессервные вычисления что это.

# WebRTC
Для обмена информацией аудио- видео-. Арзитектурные решения: есть два браузера, как они связываются и главная проблема преодалеть 